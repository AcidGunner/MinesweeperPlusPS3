<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>spr_flag</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>obj_game</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// --- Grid settings ---
first_click = true;
win = false;
grid_w = global.gridw[global.stage];
grid_h = global.gridh[global.stage];
cell_size = 16;
mine_count = global.minec[global.stage];
boss9_started = false;
boss10_started = false;
mines_left = mine_count;
temp_mines=mine_count;

if global.type_input=1 instance_create(0,0,obj_cursor);

zoom = 1;
zoom_min = 0.7;
zoom_max = 1;
zoom_speed = 0.1;
draw_size = 0;

player_x=0;
player_y=0;
test_speed=0;

msx=0;
msy=0;

bad_apple=0;
bad_apple_frame=0;

center_x = grid_w div 2;
center_y = grid_h div 2;

temp_x=-1;
temp_y=-1;
temp_g=0;
temp_111 = 1;

if global.stage==1 temp_111 = 1
else if global.stage==2 temp_111 = 1
else if global.stage==3 temp_111 = 2
else if global.stage==4 temp_111 = 2
else if global.stage==5 temp_111 = 3
else if global.stage==6 temp_111 = 3
else if global.stage==7 temp_111 = 4
else if global.stage==8 temp_111 = 4

if global.stage!=9 and global.stage!=86 and global.stage!=10
    audio_loop_sound(global._music[temp_111],global._st[temp_111],global._en[temp_111],44100,0);

if global.stage==9 or global.stage==10 audio_play_sound(mus_ocean,0,true);

spr_bg=-1;
spr_bgb=-1;

if temp_111 == 1 spr_bg=spr_bg1
else if temp_111 == 2 spr_bg=spr_bg2
else if temp_111 == 3 spr_bg=spr_bg3
else if temp_111 == 4 spr_bg=spr_bg4;

if temp_111 == 1 spr_bgb=spr_bg1b
else if temp_111 == 2 spr_bgb=spr_bg2b
else if temp_111 == 3 spr_bgb=spr_bg3b
else if temp_111 == 4 spr_bgb=spr_bg4b;

if global.stage==86
{
    spr_bg=spr_bg86;
    spr_bgb=spr_bg86b;
    bad_apple=1;
    audio_play_sound(mus_bad,0,false);
}

if global.stage==9
{
    spr_bg=spr_bg1;
    spr_bgb=spr_bg1b;
}

if global.stage==10
{
    spr_bg=spr_bg1;
    spr_bgb=spr_bg1b;
}

// --- Create grid array ---
grid = ds_grid_create(grid_w, grid_h);
reveal = ds_grid_create(grid_w, grid_h);
flagged = ds_grid_create(grid_w, grid_h);
grid_sprite = ds_grid_create(grid_w, grid_h);

// 0 = empty
// -1 = mine
// Any positive number = nearby mines

ds_grid_clear(grid, 0);
ds_grid_clear(reveal, 0);
ds_grid_clear(flagged, 0);

for (var xx = 0; xx &lt; grid_w; xx++)
for (var yy = 0; yy &lt; grid_h; yy++)
{
    grid_sprite[# xx, yy] = spr_bg; // default sprite
}

// --- Place mines ---
var placed = 0;
while (placed &lt; mine_count)
{
    var xx = irandom(grid_w - 1);
    var yy = irandom(grid_h - 1);

    if (grid[# xx, yy] != -1)
    {
        grid[# xx, yy] = -1;
        placed += 1;
    }
}

alarm[4]=1;

//grid_offset_x = (room_width  - grid_w * cell_size) / 2;
//grid_offset_y = ((room_height - grid_h * cell_size) / 2);

grid_draw_w = grid_w * cell_size * zoom;
grid_draw_h = grid_h * cell_size * zoom;

grid_offset_x = (room_width  - grid_draw_w) / 2;
grid_offset_y = ((room_height - grid_draw_h) / 2) + 25;

highlight_x1 = -1;
highlight_y1 = -1;
highlight_x2 = -1;
highlight_y2 = -1;

t9_grid=spr_bg5;
t9_gridb=spr_bg5b;
cirno9=false;

if obj_input.c_held &amp;&amp; global.stage==9
{
    secret_script_p1();
    cirno9=true;
    iceland = ds_grid_create(grid_w, grid_h);
    ds_grid_clear(iceland, 0);
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Spiral Setup
spiral = ds_list_create();
spiral_index = 0;

// Center of grid
var cx = grid_w div 2;
var cy = grid_h div 2;

spiral_go=false;

// Directions:
// 0 = right, 1 = down, 2 = left, 3 = up
var dir = 0;

// Length of movement for this step
var step = 1;

// Add center first
ds_list_add(spiral, cx &lt;&lt; 16 | cy);

// Spiral until all cells are added
while (ds_list_size(spiral) &lt; grid_w * grid_h)
{
    // Two passes per step length (right+down, then left+up)
    repeat (2)
    {
        repeat (step)
        {
            // move in current direction
            switch (dir)
            {
                case 0: cx += 1; break; // →
                case 1: cy += 1; break; // ↓
                case 2: cx -= 1; break; // ←
                case 3: cy -= 1; break; // ↑
            }
            
            // If inside bounds, add it
            if (cx &gt;= 0 &amp;&amp; cy &gt;= 0 &amp;&amp; cx &lt; grid_w &amp;&amp; cy &lt; grid_h)
            {
                ds_list_add(spiral, cx &lt;&lt; 16 | cy);
            }
        }
        
        // Next direction
        dir = (dir + 1) mod 4;
    }

    // After two directions, increase step length
    step += 1;
}

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="9">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///ICELAND
if instance_exists(obj_9) &amp;&amp; obj_9.stop exit;

var ix = irandom_range(1, grid_w - 2);
var iy = irandom_range(1, grid_h - 2);

while reveal[# ix, iy] = true
{
    var ix = irandom_range(1, grid_w - 2);
    var iy = irandom_range(1, grid_h - 2);
}

audio_play_sound(sfx_ice,9,false);
ds_grid_clear(iceland, 0);
iceland[# ix-1, iy-1] = 1;
iceland[# ix, iy-1] = 1;
iceland[# ix+1, iy-1] = 1;
iceland[# ix-1, iy] = 1;
iceland[# ix, iy] = 2;
iceland[# ix+1, iy] = 1;
iceland[# ix-1, iy+1] = 1;
iceland[# ix, iy+1] = 1;
iceland[# ix+1, iy+1] = 1;
alarm[9]=10*global.FSP;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="5">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>var xx = obj_9.grid_x;
var yy = obj_9.grid_y;

grid[# xx-1, yy-1] = -1;
grid[# xx-1, yy] = -1;
grid[# xx-1, yy+1] = -1;
grid[# xx, yy-1] = -1;
grid[# xx, yy+1] = -1;
grid[# xx+1, yy-1] = -1;
grid[# xx+1, yy] = -1;
grid[# xx+1, yy+1] = -1;
alarm[4]=1;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="4">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// === Number Fill ===
if global.stage==9 mine_count=0
for (var qx = 0; qx &lt; grid_w; qx++)
for (var qy = 0; qy &lt; grid_h; qy++)
{
    if (grid[# qx, qy] != -1)
    {
        var c = 0;

        for (var nx = qx-1; nx &lt;= qx+1; nx++)
        for (var ny = qy-1; ny &lt;= qy+1; ny++)
        {
            if (nx &gt;= 0 &amp;&amp; ny &gt;= 0 &amp;&amp; nx &lt; grid_w &amp;&amp; ny &lt; grid_h)
            {
                if (grid[# nx, ny] == -1)
                {
                    c++;
                    if global.stage==9 mine_count++;
                }
            }
        }
        
        if (grid[# qx, qy] != -2) grid[# qx, qy] = c;
    }
}
if instance_exists(obj_9) mine_count-=8;

if first_click &amp;&amp; boss9_started &amp;&amp; global.stage==9 grid[# center_x, center_y ] = 9;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="3">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>temp_x = 0;
temp_y = 0;
temp_g = 0;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="2">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Left released
var draw_size = cell_size * zoom;

check_input();
var xx = msx;
var yy = msy;

temp_g = 0;
// === VALIDATION ===
if (xx &lt; 0 || yy &lt; 0 || xx &gt;= grid_w || yy &gt;= grid_h)
{
    show_debug_message("Outside the grid?");
    temp_x=0;
    temp_y=0;
    exit; // Ignore click outside the grid
}

//show_debug_message(string(xx)+"-"+string(yy)+"??"+string(temp_x)+"-"+string(temp_y));

if obj_smiley.mine_detected != 0 exit;
if obj_smiley.cutscene == true &amp;&amp; boss9_started exit;
if obj_smiley.cutscene == true &amp;&amp; boss10_started exit;
if instance_exists(obj_9) &amp;&amp; obj_9.stop exit;

if instance_exists(obj_9) &amp;&amp; !first_click
{
    if iceland[# xx, yy] != 0 exit;
    
    if obj_9.boss_x == xx &amp;&amp; obj_9.boss_y == yy
    {
        obj_9.stop=1;
        obj_9.active=false;
        obj_9.alarm[5]=300;
        obj_smiley.temp23=obj_input.mx;
        obj_smiley.cutscene=true;
        audio_stop_all();
        audio_play_sound(sfx_done,0,false);
        exit;
    }
}

if temp_x==xx &amp;&amp; temp_y==yy
{
    if win == false
    {
        if (!boss9_started) &amp;&amp; global.stage==9
        {
            if (xx == center_x &amp;&amp; yy == center_y)
            {
                // Good! Start the game
                boss9_started = true;
                audio_stop_sound(mus_ocean);
                audio_loop_sound(global._music[5],global._st[5],global._en[5],44100,0);
                obj_smiley.alarm[0]=1;
                
                reveal[# xx, yy ] = true;
                
                //Just in case
                grid[# xx-1, yy-1] = -1;
                grid[# xx-1, yy] = -1;
                grid[# xx-1, yy+1] = -1;
                grid[# xx, yy-1] = -1;
                grid[# xx, yy+1] = -1;
                grid[# xx+1, yy-1] = -1;
                grid[# xx+1, yy] = -1;
                grid[# xx+1, yy+1] = -1;
                alarm[4]=1;
            }
            else
            {
                // Wrong square — clicking does nothing
                show_debug_message("!! Must click boss center tile first");
                exit;
            }
            
            exit; // first click handled
        }
        
        if (!boss10_started) &amp;&amp; global.stage==10
        {
            if (xx == center_x &amp;&amp; yy == center_y)
            {
                // Good! Start the game
                boss10_started = true;
                audio_stop_sound(mus_ocean);
                audio_loop_sound(global._music[11],global._st[11],global._en[11],44100,0);
                obj_smiley.alarm[5]=1;
                
                reveal[# xx, yy ] = true;
                grid[# xx, yy] = 10;
            }
            else
            {
                // Wrong square — clicking does nothing
                show_debug_message("!! Must click boss center tile first");
                exit;
            }
            
            exit; // first click handled
        }
        
        // === Safe First Click ===
        if (first_click)
        {
            first_click = false;
            
            // If the first clicked cell is a mine, rebuild the board
            if (grid[# xx, yy] == -1)
            {
                if !((xx == center_x or xx == center_x+1 or xx == center_x-1)
                and (yy == center_y or yy == center_y+1 or yy == center_y-1))
                and global.stage==9
                regenerate_grid(xx, yy, temp_mines);
            }
            
            if global.stage==9
            {
                audio_stop_all();
                audio_loop_sound(global._music[6],global._st[6],global._en[6],44100,0);
                obj_9.active=true;
                reveal[# obj_9.boss_x, obj_9.boss_y ] = false;
                alarm[9]=1;
                alarm[4]=1;
            }
            obj_ui.alarm[0]=1;
        }
        
        var cell = grid[# xx, yy];
        
        // If the clicked cell is already revealed AND is a number → try neighbor open
        if (reveal[# xx, yy] &amp;&amp; cell &gt; 0)
        {
            scr_open_neighbors(xx, yy);
            if global.stage!=9 scr_check_win();
        }
        else
        {
            // original reveal behavior
            if (!flagged[# xx, yy])
            {
                if (cell == -1)
                {
                    scr_mine_detected();
                    src_reveal_mine(xx, yy);
                }
                else
                {
                    scr_reveal(xx, yy);
                    if global.stage!=9 scr_check_win();
                }
            }
        }
    }
}

temp_x=0;
temp_y=0;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="1">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Right Clicked
var draw_size = cell_size * zoom;

check_input();
var xx = msx;
var yy = msy;

temp_g = 1;
temp_x = xx;
temp_y = yy;

// === VALIDATION ===
if (xx &lt; 0 || yy &lt; 0 || xx &gt;= grid_w || yy &gt;= grid_h) exit;

if obj_smiley.mine_detected != 0 exit;
if obj_smiley.cutscene == true &amp;&amp; boss9_started exit;
if obj_smiley.cutscene == true &amp;&amp; boss10_started exit;
if instance_exists(obj_9) &amp;&amp; obj_9.stop exit;

if win == false
{
    if iceland[# xx, yy] != 0 exit;
    
    if (xx &gt;= 0 &amp;&amp; yy &gt;= 0 &amp;&amp; xx &lt; grid_w &amp;&amp; yy &lt; grid_h)
    {
        // Toggle flag only if not revealed
        if (!reveal[# xx, yy])
        {
            flagged[# xx, yy] = !flagged[# xx, yy];
            if flagged[# xx, yy] == 0
            {
                audio_play_sound(sfx_unflag,4,false);
                mines_left++;
            }
            if flagged[# xx, yy] == 1
            {
                audio_play_sound(sfx_flag,4,false);
                mines_left--;
            }
        }
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Left clicked

var draw_size = cell_size * zoom;

check_input();
temp_x = msx;
temp_y = msy;

temp_g = 1;

// === VALIDATION ===
if (temp_x &lt; 0 || temp_y &lt; 0 || temp_x &gt;= grid_w || temp_y &gt;= grid_h) exit;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Main stuff
image_speed=0.02;
test_speed+=0.08;

// Reset highlight

highlight_x1 = -1;
highlight_y1 = -1;
highlight_x2 = -1;
highlight_y2 = -1;

check_input();

if global.stage!=86
{
    if global.type_input=0
    {
        if obj_input.lef &amp;&amp; player_x&gt;0 player_x--;
        if obj_input.rig &amp;&amp; player_x&lt;grid_w-1 player_x++;
        if obj_input.upp &amp;&amp; player_y&gt;0 player_y--;
        if obj_input.dow &amp;&amp; player_y&lt;grid_h-1 player_y++;
    }
    if obj_input.mp1 alarm[0]=1;
    if obj_input.mp2 alarm[1]=1;
    if obj_input.mh1 alarm[2]=1;
    if obj_input.mh2 alarm[3]=1;
}
else
{
    player_x=-666;
    player_y=-666;
}

if obj_input.l1 zoom -= zoom_speed;
if obj_input.r1 zoom += zoom_speed;

zoom = clamp(zoom, zoom_min, zoom_max);

grid_draw_w = grid_w * cell_size * zoom;
grid_draw_h = grid_h * cell_size * zoom;

grid_offset_x = (room_width  - grid_draw_w) / 2;
grid_offset_y = ((room_height - grid_draw_h) / 2) + 25;

// Only highlight if holding left button
if obj_input.mk1 &amp;&amp; win == false &amp;&amp; global.stage!=86
{
    if obj_smiley.mine_detected != 0 exit;
    if obj_smiley.cutscene == true &amp;&amp; boss9_started exit;
    if obj_smiley.cutscene == true &amp;&amp; boss10_started exit;
    if instance_exists(obj_9) &amp;&amp; obj_9.stop exit;
    
    // Cell must be inside the grid
    if (msx &gt;= 0 &amp;&amp; msy &gt;= 0 &amp;&amp; msx &lt; grid_w &amp;&amp; msy &lt; grid_h)
    {
        if reveal[# msx, msy]
        {
            highlight_x2 = msx;
            highlight_y2 = msy;
        }
        else if global.type_input=1
        {
            highlight_x1 = msx;
            highlight_y1 = msy;
        }
    }
}

if global.type_input=0
{
    highlight_x1 = msx;
    highlight_y1 = msy;
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Spiral weeeeee
if spiral_go == true &amp;&amp; (spiral_index &lt; ds_list_size(spiral))
{
    var v  = ds_list_find_value(spiral, spiral_index);
    var xx = v &gt;&gt; 16;
    var yy = v &amp; $FFFF;

    // Switch to your new sprite
    grid_sprite[# xx, yy] = t9_grid;
    
    spiral_index += 1;
}
else if spiral_go == true
{
    obj_bg.sprite_index=t9_grid;
    for (var xx = 0; xx &lt; grid_w; xx++)
    for (var yy = 0; yy &lt; grid_h; yy++)
    {
        grid_sprite[# xx, yy] = t9_grid; // default sprite
    }
    spr_bgb=t9_gridb;
    spiral_go = false;
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Don't ask.

if bad_apple==1
{
    bad_apple_frame+=0.5;
    if bad_apple_frame&gt;6561 game_restart();
    
    var frame = global.bad_apple[bad_apple_frame];
    var i = 1;
    
    for (var gy = 0; gy &lt; 12; gy++)
    {
        for (var gx = 0; gx &lt; 16; gx++)
        {
            var bit = real(string_char_at(frame, i));
            if bit==0 bit=1 else bit=0;
            reveal[# gx, gy] = bit;
            i++;
        }
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>for (var xx = 0; xx &lt; grid_w; xx++)
{
    for (var yy = 0; yy &lt; grid_h; yy++)
    {
        var draw_size = cell_size * zoom;
        var x1 = grid_offset_x + xx * draw_size;
        var y1 = grid_offset_y + yy * draw_size;
        
        var c_x = grid_offset_x + center_x * draw_size;
        var c_y = grid_offset_y + center_y * draw_size;
        draw_set_alpha(1);
        
        // === Base cell sprite ===
        draw_sprite_stretched(grid_sprite[# xx, yy], image_index, x1, y1, draw_size, draw_size);
        
        if !boss9_started &amp;&amp; global.stage==9
            draw_sprite_stretched(spr_highlight, test_speed, c_x, c_y, draw_size, draw_size);

        if !boss10_started &amp;&amp; global.stage==10
            draw_sprite_stretched(spr_highlight, test_speed, c_x, c_y, draw_size, draw_size);

        // === Flagged ===
        if (flagged[# xx, yy])
            draw_sprite_stretched(spr_flag, image_index, x1, y1, draw_size, draw_size);
        else if (reveal[# xx, yy])
        {
            // Dark revealed grid
            draw_sprite_stretched(spr_bgb, image_index, x1, y1, draw_size, draw_size);

            var v = grid[# xx, yy];
            if (v == -2)
                draw_sprite_stretched(spr_red_grid, 0, x1, y1, draw_size, draw_size);
            else if (v == -1)
                draw_sprite_stretched(spr_mine, 0, x1, y1, draw_size, draw_size);
            else
                draw_sprite_stretched(spr_num, v, x1, y1, draw_size, draw_size);
        }
        
        draw_set_alpha(1);
        draw_sprite_stretched(spr_grid, 0, x1, y1, draw_size, draw_size);
        if (highlight_x1 &gt;= 0 &amp;&amp; highlight_y1 &gt;= 0)
        {
            if (xx == highlight_x1 &amp;&amp; yy == highlight_y1)
            {
                draw_sprite_stretched(spr_light_grid, 0, x1, y1, draw_size, draw_size);
            }
        }
        else if (highlight_x2 &gt;= 0 &amp;&amp; highlight_y2 &gt;= 0)
        {
            if (xx &gt;= highlight_x2-1 &amp;&amp; xx &lt;= highlight_x2+1 &amp;&amp;
                yy &gt;= highlight_y2-1 &amp;&amp; yy &lt;= highlight_y2+1 &amp;&amp;
                reveal[# xx, yy]) // only highlight revealed cells
            {
                draw_sprite_stretched(spr_light_grid, 0, x1, y1, draw_size, draw_size);
            }
        }
    }
}

for (var xx = 0; xx &lt; grid_w; xx++)
{
    for (var yy = 0; yy &lt; grid_h; yy++)
    {
        var draw_size = cell_size * zoom;
        var x1 = grid_offset_x + xx * draw_size;
        var y1 = grid_offset_y + yy * draw_size;
        
        if cirno9=true &amp;&amp; iceland[# xx, yy]=2
        draw_sprite_stretched(spr_ice, image_index, x1-draw_size, y1-draw_size, draw_size*3, draw_size*3);
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
